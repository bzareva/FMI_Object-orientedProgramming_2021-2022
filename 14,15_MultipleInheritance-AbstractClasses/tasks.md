# *Множествено наследяване*
## Задача 1
Да се напише програма, която изгражда йерархията:</br>
[![Untitled-Diagram.png](https://i.postimg.cc/KzqpBxnc/Untitled-Diagram.png)](https://postimg.cc/njm1t8RN)
</br>където класът *Date* определя конкретна дата чрез цели числа, задаващи ден, месец и година, класът *Time* определя конкретно време чрез цели числа, указващи час, минути и секунди, а класът *DateTime* обединява дата и време като ги представя чрез символен низ във вида: мм/дд/гг и чч:мн:сс.
</br>
## Задача 2
Да се дефинират класове, описващи  следните видове информация:
- лични данни (име, година на раждане)
- данни за клас от ученици (випуск, брои ученици, номер на паралелка)
- данни за автомобила (марка и модел, регистрационен номер)

Да се дефинират и класове, описващи информацията за:
- класен ръководител
- собственик на автомобил

Класовете да позволяват въвеждане на съответните данни от клавиатурата и извеждането им на екрана.</br>
[![Untitled-Diag-drawio.png](https://i.postimg.cc/L5ZdsnrF/Untitled-Diag-drawio.png)](https://postimg.cc/dZvNHts5)
</br></br></br>

# *Абстрактни класове*
## Задача 3
Да се реализира абстрактен клас, дефиниращ операции над стек от цели числа. Да се изградят две реализации на стек - една с максимум 9 елемента и друга с неограничен (ограничен само от наличната памет) брой.
</br>Операциите върху стек са дефинирани в базовия абстрактен клас Stack. Създаден е негов наследник - ArrayStack, който съдържа общата функционалност на два конкретни вида стек от условието и също е абстрактен. 
</br>Двата наследника на ArrayStack - StaticArrayStack и DynamicArrayStack реализират специфичните операции за стекове с максимум 9 елемента и с "неограничен" брой елементи. </br>Реализирана е следната йерархия:
</br>
[![Untitled-Diagram-drawio.png](https://i.postimg.cc/BQfjTDNy/Untitled-Diagram-drawio.png)](https://postimg.cc/6Tz6w8kL)
</br></br>

## Задача 4
Да се реализират:
- Абстрактен базов клас *Device*, описващ техническo устройствo, който съдържа производител (низ с произволна дължина) и поддържа две операции:
  - print: за извеждане на информация за устройство
  - get_perf: за намиране на числова мярка за производителност на устройството
- Производен клас *Laptop*, описващ лаптоп, който има допълнителна член-данна за скорост (цяло число мегахерци). Да се дефинират двете операции print и get_perf, като:
  - информацията за лаптопа се състои от неговия производител и скорост
  - мярката за производителност на лаптопа е неговата скорост
- Производен клас *Car*, описващ автомобил, който има допълнителни член-данни за
мощност (цяло число киловати) и обем на двигателя (цяло число cm3 ). Да се дефинират двете операции print и get_perf, като:
  - информацията за автомобила се състои от неговия производител, мощност и
обем
  - мярката за производителност на автомобила е неговата мощност;
- Клас *Inventory*, описващ фирмен инвентар от устройства (до 100 на брой), които
могат да бъдат лаптопи и коли. Да се реализират:
  - функция, която извежда информация за всички устройства в списъка
  - функция, която проверява дали инвентарът е подреден в нарастващ ред по производителност.
</br>Забележка: реализирайте методите от голямата четворка само когато се налага, т.е. когато
системно генерираната голяма четворка не върши работа.

## Задача 5
Да се реализира абстрактен базов клас *LauncherItem*, който описва елемент на екрана на мобилно устройство и поддържа следните операции:
- getTitle, която връща низ, представящ името на елемента
- canMove, която се използва за проверка дали елементът може да бъде местен по екрана

</br>Да се реализира клас *Launcher*, който представя главния екран на мобилно устройство като правоъгълна матрица от елементи *LauncherItem*. Възможно е всяка дадена позиция в матрицата да е празна, т.е. да няма никакъв елемент на нея. За класа *Launcher* да се реализират следните операции:
- оператор << за извеждане, който извежда на стандартния изход информация за
всички елементи на екрана: позиция и име;
- операция addElement(li, i, j), която добавя нов елемент li на координати
(i, j) на екрана. В случай, че тази позиция е заета от друг елемент, операцията
добавя елемента на първото свободно място на екрана гледайки отгоре надолу и
отляво надясно. Ако на екрана няма свободно място, операцията е неуспешна.
- операция removeElement(i, j), която премахва елемента на координати (i, j)
от екрана. Ако на тези координати няма елемент или елементът не може да бъде
местен, операцията е неуспешна.
- операция moveElement(i, j, k, l), която премества елемента на координати
(i, j) на нови координати (k, l). Операцията е успешна точно тогава, когато на
позиция (i, j) има елемент, който може да бъде местен и:
  - на координати (k, l) няма елемент; ИЛИ
  - на координати (k, l) има друг елемент, който може да бъде местен. В този
случай двата елемента разменят местата си;
- операция clear, която изчиства екрана.

Да се реализират следните класове, наследници на *LauncherItem*:
- *MobileApp*, който описва стартер на мобилно приложение с дадено име. Елементите от този тип могат да се местят.
- *SystemWidget*, който описва системен елемент. Системните елементи не могат да се местят, и имат едно и също име: “System Widget”.
- *Folder*, който описва папка съдържаща елементи от вид *LauncherItem* в правоъгълна матрица. Папката поддържа всички гореописани операции на клас
*Launcher*. Папката може да бъде местена по екрана. Името на папката
представлява списък от имената на всички елементи в нея разделени със запетайка.

</br>За гореописаните класове да се реализират подходящи конструктори, селектори и
мутатори.
