## Задача 1
Реализирайте собствен шаблонен клас *Vector*. Да се инициализира с капацитет 1 и да се преоразмерява 2 пъти, когато капацитета му свърши.
Реализирайте следните методи:
- push_back - добавя елемент в края
- pop_back - премахва елемент в края
- size - връща броя на елементите във вектора
- capacity - връща капацитета на вектора
- empty - проверява дали вектора е празен
- operator[] - достъпва елемент на позиция (константна и неконстантна версия)
- clear - изтрива съдържанието на вектора

## Задача 2
 Да се реализира шаблон на клас *PriceTag< T >*, който представя етикет с цена на продукт от произволен тип T. За шаблона да се реализират:
- подходящи конструктори, селектори и мутатори<br/>
- операции >> и << за въвеждане на етикет от стандартния вход и извеждане на стандартния изход<br/>
- член-функция discount, която намалява цената на етикета с даден процент<br/>

Да се реализира шаблон на клас *PriceCatalog< T >*, който описва ценови каталог на продукти от тип T, представен с набор от до 200 етикета с
цени на продукти. За шаблона да се реализират:
- подходящ конструктор<br/>
- операция += за добавяне на етикет към каталога<br/>
- операция << за извеждане на информацията в каталога<br/>

Допускаме, че за типа T са реализирани голяма четворка и операции >> и <<.

## Задача 3
Да се дефинира шаблон на клас *Relation< T >*, който съдържа два обекта от тип T, наречени subject и object, и низ с произволна дължина relation, 
описващ връзката между тези обекти.

*Пример:* Relation<int> r1(2,6,“is smaller than”),r2(6,3,“is divisible by”);
За шаблона да се реализират голямата четворка и операция за отпечатване void print()
*Пример:* r1.print(): 2 is smaller than 6.

За инстанцията на шаблона Relation<int> реализирайте и оператор за композиция * по следния
начин.
Ако r = r1 * r2, то r.subject = r1.subject, r.object = r2.object,
r.action = r1.action r1.object “, which is“ r2.action

*Пример:* (r1*r2).print(): 2 is smaller than 6, which is divisible by 3 
Композицията се допуска само ако r1.object == r2.subject, в противен случай резултатът e r1.

## Задача 4
Да се реализира шаблон на клас *Relation*, който описва релация между елементи от тип T и елементи от тип U. 
Релацията се представя като последователност от двойки, които са в релация. За шаблона да се реализират следните операции:
- подходящи конструктори
- r1 + r2, която намира обединението на r1 и r2 (всички двойки (t,u), които са в релация r1 или в релация r2)
- r1 ^ r2, която намира сечението на r1 и r2 (всички двойки (t,u), които са в релация r1 и в релация r2)
- r[t], която намира образът на елемента t (всички елементи u, за които (t,u) са в релация r)
- r(u), която намира първообраза на елемента u (всички елементи t, за които (t,u) са в релация r)
- r1 * r2, която намира композицията на релациите r1 и r2 (всички двойки (t,v), за които има u, така че (t,u) е в r1 и (u,v) е в r2)
- r.dom(), която намира домейна на r (всички елементи t, които участват в някоя двойка (t,u) от r)
- r.ran(), която намира образа на r (всички елементи u, които участват в някоя двойка (t,u) от r)

## Задача 5
Да се реализира шаблон на клас *Dictionary* с два типови параметъра K и V. Класът да
представя речник, който съдържа редица от ключове от тип K и на всеки ключ съпоставя по
една стойност от тип V. Едно примерно представяне би могло да бъде с два масива с една
и съща дължина — един с елементи от тип K и един с елементи от тип V. За типа K и V
може да се приеме, че са налични:
- голяма четворка
- операция за изход <<
- операции за сравнение == и !=
- за типа К допълнително са налични операции за наредба <, <=, >, >=

За класа да се реализират:
- голяма четворка
- добавяне на ключ и съответна на него стойност
- търсене на стойност по ключ
- извежда речника на стандартния вход подреден по ключ
- разширяване на речника при изчерпване на капацитета му

## Задача 6
Да се реализира шаблон на клас *Counters< T >*, съдържащ два брояча, които помнят колко пъти е прочетена и колко пъти е променена стойността на 
данна от тип T. За шаблона да се реализират подходящи селектори, мутатори и операция +=, която добавя броячите на подаден обект от тип *Counters< T >*, 
но само ако данната от тип T съвпада (в смисъла на ==). Да се реализира шаблон на клас CounterArray<T>, който представя масив от данни от тип T с броячи.
За шаблона да се реализират функциите:
- операция [], която дава достъп за четене до пореден елемент
- sort, която сортира масив от елементи от тип T по метода на пряката селекция и извежда статистика за това кой елемент от масива колко пъти е бил използван 
- statistics, която използва операцията +=, за да изведе статистика за използването всеки уникален елемент от масива
  
## Задача 7
Да се реализира клас *Sorted< T >*, който реализира "винаги сортиран" масив от елементи T. В *Sorted< T >* може да има максимум 128 елемента от тип T.
Класът да има методи add(T& elem), remove (T& elem) и print(), които съответно добавят елемент, махат елемент и отпечатват елементите разделени с нов ред.
    

